$PBExportHeader$m_batch_correspondence.srm
$PBExportComments$Batch Printing Menu
forward
global type m_batch_correspondence from menu
end type
type m_file from menu within m_batch_correspondence
end type
type m_outofoffice from menu within m_file
end type
type m_- from menu within m_file
end type
type m_clearsearch from menu within m_file
end type
type m_search from menu within m_file
end type
type m_filesep1 from menu within m_file
end type
type m_printsetup from menu within m_file
end type
type m_printselectedcorrespondence from menu within m_file
end type
type m_printall from menu within m_file
end type
type m_filesep2 from menu within m_file
end type
type m_close from menu within m_file
end type
type m_filesep3 from menu within m_file
end type
type m_exit from menu within m_file
end type
type m_file from menu within m_batch_correspondence
m_outofoffice m_outofoffice
m_- m_-
m_clearsearch m_clearsearch
m_search m_search
m_filesep1 m_filesep1
m_printsetup m_printsetup
m_printselectedcorrespondence m_printselectedcorrespondence
m_printall m_printall
m_filesep2 m_filesep2
m_close m_close
m_filesep3 m_filesep3
m_exit m_exit
end type
type m_edit from menu within m_batch_correspondence
end type
type m_cut from menu within m_edit
end type
type m_copy from menu within m_edit
end type
type m_paste from menu within m_edit
end type
type m_-0 from menu within m_edit
end type
type m_selectall from menu within m_edit
end type
type m_edit from menu within m_batch_correspondence
m_cut m_cut
m_copy m_copy
m_paste m_paste
m_-0 m_-0
m_selectall m_selectall
end type
type m_features from menu within m_batch_correspondence
end type
type m_createmaintaincase from menu within m_features
end type
type m_workdesk from menu within m_features
end type
type m_documentsfullinterface from menu within m_features
end type
type m_recordsurveyresults from menu within m_features
end type
type m_sleepmode from menu within m_features
end type
type m_features from menu within m_batch_correspondence
m_createmaintaincase m_createmaintaincase
m_workdesk m_workdesk
m_documentsfullinterface m_documentsfullinterface
m_recordsurveyresults m_recordsurveyresults
m_sleepmode m_sleepmode
end type
type m_administration from menu within m_batch_correspondence
end type
type m_userlicenses from menu within m_administration
end type
type m_updatelicenseinformation from menu within m_userlicenses
end type
type m_manageuserlogins from menu within m_userlicenses
end type
type m_userlicenses from menu within m_administration
m_updatelicenseinformation m_updatelicenseinformation
m_manageuserlogins m_manageuserlogins
end type
type m_options from menu within m_administration
end type
type m_casehousekeeping from menu within m_administration
end type
type m_tablemaintenance from menu within m_administration
end type
type m_supervisorportal from menu within m_administration
end type
type m_lockedrecords from menu within m_administration
end type
type m_administration from menu within m_batch_correspondence
m_userlicenses m_userlicenses
m_options m_options
m_casehousekeeping m_casehousekeeping
m_tablemaintenance m_tablemaintenance
m_supervisorportal m_supervisorportal
m_lockedrecords m_lockedrecords
end type
type m_window from menu within m_batch_correspondence
end type
type m_tile from menu within m_window
end type
type m_layer from menu within m_window
end type
type m_cascade from menu within m_window
end type
type m_windowsep1 from menu within m_window
end type
type m_arrangeicons from menu within m_window
end type
type m_windowsep2 from menu within m_window
end type
type m_closeall from menu within m_window
end type
type m_window from menu within m_batch_correspondence
m_tile m_tile
m_layer m_layer
m_cascade m_cascade
m_windowsep1 m_windowsep1
m_arrangeicons m_arrangeicons
m_windowsep2 m_windowsep2
m_closeall m_closeall
end type
type m_help from menu within m_batch_correspondence
end type
type m_index from menu within m_help
end type
type m_usinghelp from menu within m_help
end type
type m_helpsep1 from menu within m_help
end type
type m_about from menu within m_help
end type
type m_help from menu within m_batch_correspondence
m_index m_index
m_usinghelp m_usinghelp
m_helpsep1 m_helpsep1
m_about m_about
end type
global type m_batch_correspondence from menu
m_file m_file
m_edit m_edit
m_features m_features
m_administration m_administration
m_window m_window
m_help m_help
end type
end forward

global type m_batch_correspondence from menu
m_file m_file
m_edit m_edit
m_features m_features
m_administration m_administration
m_window m_window
m_help m_help
end type
global m_batch_correspondence m_batch_correspondence

type variables



end variables

forward prototypes
public subroutine fm_editoperation (string a_coperation)
end prototypes

public subroutine fm_editoperation (string a_coperation);/****************************************************************************************

  Function: fm_EditOperation
   Purpose: To cut, copy and paste to or from the system clipboard.  Also select all text
				in the editable control.
	
Parameters: a_cOperation - The operation to be perfomed
									cut - Cut Contents to the Clipboard
									copy - Copy Contents to the Clipboard
									paste - Paste Contents from the Clipboard
									selectall - Select all of the text in the edit control
	Returns: None
	
 Revisions: Date     Developer     Description
            ======== ============= ======================================================
				4/30/2001 K. Claver    Created

****************************************************************************************/
GraphicObject l_goObject
DataWindow l_dwObject
SingleLineEdit l_sleObject
MultiLineEdit l_mleObject
EditMask l_emObject
RichTextEdit l_rteObject
DropDownListBox l_ddlbObject
DropDownPictureListBox l_ddplbObject
Boolean l_bOk = TRUE

l_goObject = GetFocus( )

CHOOSE CASE TypeOf( l_goObject )
	CASE SingleLineEdit!
		l_sleObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_sleObject.Cut( )
			CASE "COPY"
				l_sleObject.Copy( )
			CASE "PASTE"
				l_sleObject.Paste( )
			CASE "SELECTALL"
				l_sleObject.SelectText( 1, Len( l_sleObject.Text ) )
		END CHOOSE
	CASE EditMask!
		l_emObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_emObject.Cut( )
			CASE "COPY"
				l_emObject.Copy( )
			CASE "PASTE"
				l_emObject.Paste( )
			CASE "SELECTALL"
				l_emObject.SelectText( 1, Len( l_emObject.Text ) )
		END CHOOSE
	CASE RichTextEdit!
		l_rteObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_rteObject.Cut( )
			CASE "COPY"
				l_rteObject.Copy( )
			CASE "PASTE"
				l_rteObject.Paste( )
			CASE "SELECTALL"
				l_rteObject.SelectTextAll( )
		END CHOOSE
	CASE DropDownListBox!
		l_ddlbObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_ddlbObject.Cut( )
			CASE "COPY"
				l_ddlbObject.Copy( )
			CASE "PASTE"
				l_ddlbObject.Paste( )
			CASE "SELECTALL"
				l_ddlbObject.SelectText( 1, Len( l_ddlbObject.Text ) )
		END CHOOSE
	CASE DropDownPictureListBox!
		l_ddplbObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_ddplbObject.Cut( )
			CASE "COPY"
				l_ddplbObject.Copy( )
			CASE "PASTE"
				l_ddplbObject.Paste( )
			CASE "SELECTALL"
				l_ddplbObject.SelectText( 1, Len( l_ddplbObject.Text ) )
		END CHOOSE
	CASE DataWindow!
		l_dwObject = l_goObject
		CHOOSE CASE Upper( a_cOperation )
			CASE "CUT"
				l_dwObject.Cut( )
			CASE "COPY"
				l_dwObject.Copy( )
			CASE "PASTE"
				l_dwObject.Paste( )
			CASE "SELECTALL"
				l_dwObject.SelectText(1, Len( l_dwObject.GetText( ) ) )
		END CHOOSE
END CHOOSE		
end subroutine

on m_batch_correspondence.create
m_batch_correspondence=this
call super::create
this.m_file=create m_file
this.m_edit=create m_edit
this.m_features=create m_features
this.m_administration=create m_administration
this.m_window=create m_window
this.m_help=create m_help
this.Item[UpperBound(this.Item)+1]=this.m_file
this.Item[UpperBound(this.Item)+1]=this.m_edit
this.Item[UpperBound(this.Item)+1]=this.m_features
this.Item[UpperBound(this.Item)+1]=this.m_administration
this.Item[UpperBound(this.Item)+1]=this.m_window
this.Item[UpperBound(this.Item)+1]=this.m_help
end on

on m_batch_correspondence.destroy
call super::destroy
destroy(this.m_file)
destroy(this.m_edit)
destroy(this.m_features)
destroy(this.m_administration)
destroy(this.m_window)
destroy(this.m_help)
end on

type m_file from menu within m_batch_correspondence
m_outofoffice m_outofoffice
m_- m_-
m_clearsearch m_clearsearch
m_search m_search
m_filesep1 m_filesep1
m_printsetup m_printsetup
m_printselectedcorrespondence m_printselectedcorrespondence
m_printall m_printall
m_filesep2 m_filesep2
m_close m_close
m_filesep3 m_filesep3
m_exit m_exit
end type

on m_file.create
call super::create
this.text = "&File"
this.m_outofoffice=create m_outofoffice
this.m_-=create m_-
this.m_clearsearch=create m_clearsearch
this.m_search=create m_search
this.m_filesep1=create m_filesep1
this.m_printsetup=create m_printsetup
this.m_printselectedcorrespondence=create m_printselectedcorrespondence
this.m_printall=create m_printall
this.m_filesep2=create m_filesep2
this.m_close=create m_close
this.m_filesep3=create m_filesep3
this.m_exit=create m_exit
this.Item[UpperBound(this.Item)+1]=this.m_outofoffice
this.Item[UpperBound(this.Item)+1]=this.m_-
this.Item[UpperBound(this.Item)+1]=this.m_clearsearch
this.Item[UpperBound(this.Item)+1]=this.m_search
this.Item[UpperBound(this.Item)+1]=this.m_filesep1
this.Item[UpperBound(this.Item)+1]=this.m_printsetup
this.Item[UpperBound(this.Item)+1]=this.m_printselectedcorrespondence
this.Item[UpperBound(this.Item)+1]=this.m_printall
this.Item[UpperBound(this.Item)+1]=this.m_filesep2
this.Item[UpperBound(this.Item)+1]=this.m_close
this.Item[UpperBound(this.Item)+1]=this.m_filesep3
this.Item[UpperBound(this.Item)+1]=this.m_exit
end on

on m_file.destroy
call super::destroy
destroy(this.m_outofoffice)
destroy(this.m_-)
destroy(this.m_clearsearch)
destroy(this.m_search)
destroy(this.m_filesep1)
destroy(this.m_printsetup)
destroy(this.m_printselectedcorrespondence)
destroy(this.m_printall)
destroy(this.m_filesep2)
destroy(this.m_close)
destroy(this.m_filesep3)
destroy(this.m_exit)
end on

type m_outofoffice from menu within m_file
end type

event clicked;//**********************************************************************************************
//
//  Event:   clicked
//  Purpose: Add or Remove Out of Office
//  
//  Date     Developer   Description
//  -------- ----------- -----------------------------------------------------------------------
//  09/28/00 cjackson    Original Version
//  12/08/00 cjackson    Update routed.bmp as necessary
//  12/13/00 cjackson    Add logic to prevent marking out of office if cases are being routed
//
//**********************************************************************************************

STRING l_cNewKey, l_cWindowTitle, l_cAssignedTo, l_cBMP, l_cOutUser
LONG l_nCount, l_nIndex
DATETIME l_dtCreateDate
LONG l_nPos

l_cWindowTitle = w_mdi.Title 

IF w_batch_correspondence.i_bOutOfOffice THEN
	// Check to see if this CSR's cases are being route to another CSR
	SELECT assigned_to_user_id INTO :l_cAssignedTo
	  FROM cusfocus.out_of_office
	 WHERE out_user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;
	 
	IF NOT ISNULL(l_cAssignedTo) THEN
		// See if this CSR is also being routed another CSR's cases
		SELECT COUNT (*) INTO :l_nCount
		  FROM cusfocus.out_of_office
		 WHERE assigned_to_user_id = :l_cAssignedTo
		 USING SQLCA;
		
		IF l_nCount = 1 THEN
			// This is the only route record, set the icon back to person.bmp
			UPDATE cusfocus.cusfocus_user
				SET out_of_office_bmp = 'person.bmp'
			 WHERE user_id = :l_cAssignedTo
			 USING SQLCA;
		END IF
		 
	END IF
	
	// Mark the CSR in the office
	SELECT assigned_to_user_id INTO :l_cAssignedTo
	  FROM cusfocus.out_of_office
	 WHERE out_user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;
	 
	// Remove Out of Office
	DELETE cusfocus.out_of_office
	 WHERE out_user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;

	// Determine if the icon should be 'routed.bmp' (if this CSR is being routed
	// another CSR's cases) or 'person.bmp' (they are not)
	SELECT COUNT (*) INTO :l_nCount
	  FROM cusfocus.out_of_office
	 WHERE assigned_to_user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;
	 
	IF l_nCount > 0 THEN 
		l_cBMP = 'routed.bmp' 
	ELSE
		l_cBMP = 'person.bmp'
	END IF
	
	UPDATE cusfocus.cusfocus_user
	   SET out_of_office_bmp = :l_cBMP
	 WHERE user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;
	 
	// Make sure window title is not already modified
	l_nPos = POS(l_cWindowTitle,' ***')
	IF l_nPos > 0 THEN
		l_cWindowTitle = TRIM(MID(l_cWindowTitle,1,l_nPos))
		w_mdi.Title = l_cWindowTitle
	END IF
	
	THIS.UnCheck()
	w_batch_correspondence.i_bOutOfOffice = FALSE
	
ELSE
	// Make sure the user is not being routed cases from someone else before marking out of office
	SELECT COUNT(*) INTO :l_nIndex
	  FROM cusfocus.out_of_office
	 WHERE assigned_to_user_id = :w_batch_correspondence.i_cUserID
	 USING SQLCA;
	 
	IF l_nIndex > 0 THEN
		// Can't mark out of office...
		messagebox(gs_AppName, 'You are currently being routed cases, you cannot mark yourself out of office')
		RETURN
		
	ELSE

	
		//Mark the user out of office
		l_dtCreateDate = DateTime(Today())
		l_cNewKey = w_batch_correspondence.fw_getkeyvalue('out_of_office')
		
		// Make sure this person hasn't been marked Out of Office in the meantime
		SELECT count (*) INTO :l_nCount
		  FROM cusfocus.out_of_office
		 WHERE out_user_id = :w_batch_correspondence.i_cUserID
		 USING SQLCA;
		 
		IF l_nCount = 0 THEN 
		
			INSERT INTO cusfocus.out_of_office (out_of_office_id, out_user_id, updated_by, updated_timestamp)
			VALUES (:l_cNewKey, :w_batch_correspondence.i_cUserID, :w_batch_correspondence.i_cUserID, :l_dtCreateDate)
			USING SQLCA;									 
			
			//Update the icon to out_of_office.bmp
			UPDATE cusfocus.cusfocus_user
				SET out_of_office_bmp = 'out_of_office.bmp'
			 WHERE user_id = :w_batch_correspondence.i_cUserID
			 USING SQLCA;
		
		END IF
	
		// Make sure window title is not already modified
		l_nPos = POS(l_cWindowTitle,' ***')
		IF l_nPos = 0 THEN
			w_mdi.Title = w_mdi.Title + ' *** Out of Office'
		END IF
		
	END IF

	THIS.Check()
	w_batch_correspondence.i_bOutOfOffice = TRUE
	
END IF


end event

on m_outofoffice.create
call super::create
this.text = "&Out of Office"
end on

on m_outofoffice.destroy
call super::destroy
end on

type m_- from menu within m_file
end type

on m_-.create
call super::create
this.text = "-"
end on

on m_-.destroy
call super::destroy
end on

type m_clearsearch from menu within m_file
end type

on clicked;/********************************************************************************

		Event:	clicked
		Purpose:	To clear the Search Criteria

**********************************************************************************/

W_BATCH_CORRESPONDENCE l_wParentWindow

l_wParentWindow = FWCA.MGR.i_MDIFrame.GetActiveSheet()

IF IsValid(l_wParentWIndow) THEN
	l_wParentWindow.fw_clearsearch()
END IF
end on

on m_clearsearch.create
call super::create
this.text = "C&lear Search"
this.microhelp = "Clears the Search Criteria"
this.toolbaritemname = "ei0087-48.ico"
this.toolbaritemtext = "Clear Search Criteria"
this.toolbaritemorder = 1
end on

on m_clearsearch.destroy
call super::destroy
end on

type m_search from menu within m_file
end type

event clicked;/****************************************************************************************
	Event:	clicked 
	Purpose:	To trigger the search for the datawindow
	
	Revisions:
	Date     Developer     Description
	======== ============= ===============================================================
	03/27/02 M. Caruso     Updated the code to not process if an error occurs in criteria
								  validation.
****************************************************************************************/

BOOLEAN	l_bContinue
INTEGER	l_nTotalColumns, l_nInitialColumn, l_nIndex
LONG		l_nRow
STRING	l_cColName, l_cValue
U_DW_SEARCH					l_dwSearch
W_BATCH_CORRESPONDENCE	l_wParentWindow

// get and validate the parent window reference.
l_wParentWindow = FWCA.MGR.i_MDIFrame.GetActiveSheet()
IF IsValid(l_wParentWindow) THEN
	
	// disable screen refresh until done
	l_wParentWindow.SetRedraw (FALSE)
	
	l_dwSearch = l_wParentWindow.dw_search_criteria
	l_dwSearch.AcceptText ()
	
	l_bContinue = FALSE
	l_nRow = l_dwSearch.GetRow ()
	l_nTotalColumns = INTEGER (l_dwSearch.Object.Datawindow.Column.Count)
	l_nInitialColumn = l_dwSearch.GetColumn ()
	
	// if the value in the current column is valid, proceed
	IF l_dwSearch.i_SearchError = l_dwSearch.c_ValOK OR &
		l_dwSearch.i_SearchError = l_dwSearch.c_ValFixed THEN
		
		// loop through and validate all columns
		FOR l_nIndex = 1 TO l_nTotalColumns
			
			l_dwSearch.SetColumn (l_nIndex)
			IF (l_dwSearch.i_SearchError = l_dwSearch.c_ValOK) OR &
				(l_dwSearch.i_SearchError = l_dwSearch.c_ValFixed) THEN
				
				// this item passed validation
				l_cColName = l_dwSearch.Describe ('#' + STRING (l_nIndex) + '.Name')
				l_cValue = l_dwSearch.fu_SelectCode (l_cColName)
				
				// if value does not specify a pure wildcard search, allow to continue
				IF l_cValue <> '%' AND TRIM (l_cValue) <> '' THEN l_bContinue = TRUE
				
			ELSE
				
				// something failed validation, so stop processing.
				l_bContinue = FALSE
				EXIT
				
			END IF
			
		NEXT
		
		l_dwSearch.SetColumn (l_nInitialColumn)
		
		IF l_bContinue THEN
			l_wParentWindow.dw_matched_records.Event Trigger ue_search( )
		ELSE
			// do not display message is bad data caused continue to be FALSE.
			IF (l_dwSearch.i_SearchError = l_dwSearch.c_ValOK) OR &
				(l_dwSearch.i_SearchError = l_dwSearch.c_ValFixed) THEN
				MessageBox ("Search Criteria", "You must either use a date range or more specific criteria than 'All' to execute the search.")
			END IF
		END IF
		
	END IF
	
	// enable screen refresh
	l_wParentWindow.SetRedraw (TRUE)
	
END IF
end event

on m_search.create
call super::create
this.text = "&Search"
this.microhelp = "Searches for records based on the Search Criteria"
this.toolbaritemname = "ni0104-48.ico"
this.toolbaritemtext = "Search"
this.toolbaritemorder = 2
end on

on m_search.destroy
call super::destroy
end on

type m_filesep1 from menu within m_file
end type

on m_filesep1.create
call super::create
this.text = "-"
end on

on m_filesep1.destroy
call super::destroy
end on

type m_printsetup from menu within m_file
end type

on clicked;PrintSetup()
end on

on m_printsetup.create
call super::create
this.text = "Prin&t Setup"
this.microhelp = "Opens the Window Print Setup window"
end on

on m_printsetup.destroy
call super::destroy
end on

type m_printselectedcorrespondence from menu within m_file
end type

event clicked;/****************************************************************************************
	Event:	clicked
	Purpose:	To print the selected correspondence.
	
	Revisions:
	Date     Developer     Description
	======== ============= ===============================================================
	07/06/01 M. Caruso     Modified to use the new correspondence manager.
	01/25/02 M. Caruso     Modified to use the newly revised correspondence manager.
	02/12/02 M. Caruso     Set i_bFromPrint to TRUE.
	03/28/02 M. Caruso     Set i_bCaseLocked in l_uoDocMgr to FALSE.
****************************************************************************************/

LONG							l_nRowCount, l_nIndex, l_nRows[], l_nCurrentRow
S_DOC_INFO					l_sDocInfo[]
U_DW_STD						l_dwMatchedRecords
U_CORRESPONDENCE_MGR		l_uoDocMgr
W_BATCH_CORRESPONDENCE	l_wParentWindow

l_wParentWindow = FWCA.MGR.i_MDIFrame.GetActiveSheet()

IF IsValid(l_wParentWindow) THEN
	
	// prevent screen updates
	l_wParentWindow.SetRedraw (FALSE)
	
	// gather info about the docs to process
	l_dwMatchedRecords = l_wParentWindow.dw_matched_records
	l_nRowCount  = l_dwMatchedRecords.fu_GetSelectedRows (l_nRows[])
	FOR l_nIndex = 1 TO l_nRowCount
		
		l_nCurrentRow = l_nRows[l_nIndex]
		l_sDocInfo[l_nIndex].a_cDocID = l_dwMatchedRecords.GetItemString (l_nCurrentRow, 'correspondence_id')
		l_sDocInfo[l_nIndex].a_cDocName = l_dwMatchedRecords.GetItemString (l_nCurrentRow, 'letter_name')
		l_sDocInfo[l_nIndex].a_cCaseNumber = l_dwMatchedRecords.GetItemString (l_nCurrentRow, 'case_number')
		l_sDocInfo[l_nIndex].a_cCaseType = l_dwMatchedRecords.GetItemString (l_nCurrentRow, 'case_type')
		l_sDocInfo[l_nIndex].a_dtSent = l_dwMatchedRecords.GetItemDateTime (l_nCurrentRow, 'correspondence_corspnd_sent')
		IF l_dwMatchedRecords.GetItemString (l_nCurrentRow, 'correspondence_corspnd_doc_filled') = 'Y' THEN
			l_sDocInfo[l_nIndex].a_bFilled = TRUE
		ELSE
			l_sDocInfo[l_nIndex].a_bFilled = FALSE
		END IF
		
	NEXT
		
	// process the correspondence
	l_uoDocMgr = CREATE U_CORRESPONDENCE_MGR
	l_uoDocMgr.i_dwRefreshDW = l_dwMatchedRecords
	l_uoDocMgr.i_bCaseLocked = FALSE
	l_uoDocMgr.uf_processdocs (l_sDocInfo[], TRUE, TRUE)
	l_uoDocMgr.uf_CloseDocWindow()
	DESTROY l_uoDocMgr
	l_wParentWindow.i_bFromPrint = TRUE
	
	// refresh the results list
	l_wParentWindow.dw_matched_records.Event Trigger ue_search ()
	
	// update the screen
	l_wParentWindow.SetRedraw (TRUE)
	
END IF
end event

on m_printselectedcorrespondence.create
call super::create
this.text = "&Print Selected Correspondence"
this.microhelp = "Prints the Selected Correspondence"
this.toolbaritemname = "wi0146-48.ico"
this.toolbaritemtext = "Print"
this.toolbaritemorder = 3
this.toolbaritemspace = 1
end on

on m_printselectedcorrespondence.destroy
call super::destroy
end on

type m_printall from menu within m_file
end type

event clicked;/****************************************************************************************
	Event:	clicked
	Purpose:	To print the selected correspondence.
	
	Revisions:
	Date     Developer     Description
	======== ============= ===============================================================
	07/10/01 M. Caruso     Modified to use the new correspondence manager.
	01/25/02 M. Caruso     Modified to use the newly revised correspondence manager.
	02/12/02 M. Caruso     Set i_bFromPrint to TRUE.
	03/28/02 M. Caruso     Set i_bCaseLocked in l_uoDocMgr to FALSE.
****************************************************************************************/

LONG							l_nRowCount, l_nIndex
S_DOC_INFO					l_sDocInfo[]
U_DW_STD						l_dwMatchedRecords
U_CORRESPONDENCE_MGR		l_uoDocMgr
W_BATCH_CORRESPONDENCE	l_wParentWindow

l_wParentWindow = FWCA.MGR.i_MDIFrame.GetActiveSheet()

IF IsValid(l_wParentWindow) THEN
	
	// prevent screen updates
	l_wParentWindow.SetRedraw (FALSE)
	
	// gather info about the docs to process
	l_dwMatchedRecords = l_wParentWindow.dw_matched_records
	l_nRowCount  = l_dwMatchedRecords.RowCount ()
	FOR l_nIndex = 1 TO l_nRowCount
		
		l_sDocInfo[l_nIndex].a_cDocID = l_dwMatchedRecords.GetItemString (l_nIndex, 'correspondence_id')
		l_sDocInfo[l_nIndex].a_cDocName = l_dwMatchedRecords.GetItemString (l_nIndex, 'letter_name')
		l_sDocInfo[l_nIndex].a_cCaseNumber = l_dwMatchedRecords.GetItemString (l_nIndex, 'case_number')
		l_sDocInfo[l_nIndex].a_cCaseType = l_dwMatchedRecords.GetItemString (l_nIndex, 'case_type')
		l_sDocInfo[l_nIndex].a_dtSent = l_dwMatchedRecords.GetItemDateTime (l_nIndex, 'correspondence_corspnd_sent')
		IF l_dwMatchedRecords.GetItemString (l_nIndex, 'correspondence_corspnd_doc_filled') = 'Y' THEN
			l_sDocInfo[l_nIndex].a_bFilled = TRUE
		ELSE
			l_sDocInfo[l_nIndex].a_bFilled = FALSE
		END IF
		
	NEXT
		
	// process the correspondence
	l_uoDocMgr = CREATE U_CORRESPONDENCE_MGR
	l_uoDocMgr.i_bCaseLocked = FALSE
	l_uoDocMgr.i_dwRefreshDW = l_dwMatchedRecords
	l_uoDocMgr.uf_processdocs (l_sDocInfo[], TRUE, TRUE)
	l_wParentWindow.i_bFromPrint = TRUE
	
	// refresh the results list
	l_wParentWindow.dw_matched_records.Event Trigger ue_search ()
	
	// update the screen
	l_wParentWindow.SetRedraw (TRUE)
	
END IF
end event

on m_printall.create
call super::create
this.text = "Print &All"
this.microhelp = "Prints All Correspondence"
end on

on m_printall.destroy
call super::destroy
end on

type m_filesep2 from menu within m_file
end type

on m_filesep2.create
call super::create
this.text = "-"
end on

on m_filesep2.destroy
call super::destroy
end on

type m_close from menu within m_file
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_CloseFile
//  Event         : Clicked
//  Description   : Close the current window.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF IsValid(FWCA.MGR.i_WindowCurrent) THEN
   Close(FWCA.MGR.i_WindowCurrent)
END IF
end on

on m_close.create
call super::create
this.text = "&Close"
this.microhelp = "Close the currently selected window"
end on

on m_close.destroy
call super::destroy
end on

type m_filesep3 from menu within m_file
end type

on m_filesep3.create
call super::create
this.text = "-"
end on

on m_filesep3.destroy
call super::destroy
end on

type m_exit from menu within m_file
end type

event clicked;//******************************************************************
//  PC Module     : m_Main.m_Exit
//  Event         : Clicked
//  Description   : Exit the application by closing the top
//                  level window.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1994.  All Rights Reserved.
//******************************************************************

FWCA.MGR.fu_ExitApp()
end event

on m_exit.create
call super::create
this.text = "E&xit"
this.microhelp = "Exit the application"
end on

on m_exit.destroy
call super::destroy
end on

type m_edit from menu within m_batch_correspondence
m_cut m_cut
m_copy m_copy
m_paste m_paste
m_-0 m_-0
m_selectall m_selectall
end type

on m_edit.create
call super::create
this.text = "&Edit"
this.m_cut=create m_cut
this.m_copy=create m_copy
this.m_paste=create m_paste
this.m_-0=create m_-0
this.m_selectall=create m_selectall
this.Item[UpperBound(this.Item)+1]=this.m_cut
this.Item[UpperBound(this.Item)+1]=this.m_copy
this.Item[UpperBound(this.Item)+1]=this.m_paste
this.Item[UpperBound(this.Item)+1]=this.m_-0
this.Item[UpperBound(this.Item)+1]=this.m_selectall
end on

on m_edit.destroy
call super::destroy
destroy(this.m_cut)
destroy(this.m_copy)
destroy(this.m_paste)
destroy(this.m_-0)
destroy(this.m_selectall)
end on

type m_cut from menu within m_edit
end type

on m_cut.create
call super::create
this.text = "Cut~tCtrl+X"
this.shortcut = 344
this.microhelp = "Cut Contents to Clipboard"
this.toolbaritemname = "wi0085-48.ico"
this.toolbaritemtext = "Cut Contents to Clipboard"
this.toolbaritemorder = 30
this.toolbaritemspace = 1
end on

on m_cut.destroy
call super::destroy
end on

event clicked;/****************************************************************************************

     Event: clicked
   Purpose: Please see PB documentation for this event
	
	
 Revisions: Date     Developer     Description
            ======== ============= ======================================================
				4/30/2001 K. Claver    Added function call to cut the contents of the object
											  to the clipboard

****************************************************************************************/
fm_EditOperation( "CUT" )
end event

type m_copy from menu within m_edit
end type

on m_copy.create
call super::create
this.text = "Copy~tCtrl+C"
this.shortcut = 323
this.microhelp = "Copy Contents to Clipboard"
this.toolbaritemname = "wi0039-48.ico"
this.toolbaritemtext = "Copy Contents to Clipboard"
this.toolbaritemorder = 31
end on

on m_copy.destroy
call super::destroy
end on

event clicked;/****************************************************************************************

     Event: clicked
   Purpose: Please see PB documentation for this event
	
	
 Revisions: Date     Developer     Description
            ======== ============= ======================================================
				4/30/2001 K. Claver    Added function call to copy the contents of the object
											  to the clipboard

****************************************************************************************/
fm_EditOperation( "COPY" )
end event

type m_paste from menu within m_edit
end type

on m_paste.create
call super::create
this.text = "Paste~tCtrl+V"
this.shortcut = 342
this.microhelp = "Paste Contents of Clipboard"
this.toolbaritemname = "wi0020-48.ico"
this.toolbaritemtext = "Paste Contents of Clipboard"
this.toolbaritemorder = 32
end on

on m_paste.destroy
call super::destroy
end on

event clicked;/****************************************************************************************

     Event: clicked
   Purpose: Please see PB documentation for this event
	
	
 Revisions: Date     Developer     Description
            ======== ============= ======================================================
				4/30/2001 K. Claver    Added function call to paste the contents of the clipboard
											  into the object

****************************************************************************************/
fm_EditOperation( "PASTE" )
end event

type m_-0 from menu within m_edit
end type

on m_-0.create
call super::create
this.text = "-"
end on

on m_-0.destroy
call super::destroy
end on

type m_selectall from menu within m_edit
end type

on m_selectall.create
call super::create
this.text = "Select All~tCtrl+A"
this.shortcut = 321
this.microhelp = "Select All"
end on

on m_selectall.destroy
call super::destroy
end on

event clicked;/****************************************************************************************

     Event: clicked
   Purpose: Please see PB documentation for this event
	
	
 Revisions: Date     Developer     Description
            ======== ============= ======================================================
				4/30/2001 K. Claver    Added function call to select the contents of the object.
											  
****************************************************************************************/
fm_EditOperation( "SELECTALL" )
end event

type m_features from menu within m_batch_correspondence
m_createmaintaincase m_createmaintaincase
m_workdesk m_workdesk
m_documentsfullinterface m_documentsfullinterface
m_recordsurveyresults m_recordsurveyresults
m_sleepmode m_sleepmode
end type

on m_features.create
call super::create
this.text = "Fea&tures"
this.m_createmaintaincase=create m_createmaintaincase
this.m_workdesk=create m_workdesk
this.m_documentsfullinterface=create m_documentsfullinterface
this.m_recordsurveyresults=create m_recordsurveyresults
this.m_sleepmode=create m_sleepmode
this.Item[UpperBound(this.Item)+1]=this.m_createmaintaincase
this.Item[UpperBound(this.Item)+1]=this.m_workdesk
this.Item[UpperBound(this.Item)+1]=this.m_documentsfullinterface
this.Item[UpperBound(this.Item)+1]=this.m_recordsurveyresults
this.Item[UpperBound(this.Item)+1]=this.m_sleepmode
end on

on m_features.destroy
call super::destroy
destroy(this.m_createmaintaincase)
destroy(this.m_workdesk)
destroy(this.m_documentsfullinterface)
destroy(this.m_recordsurveyresults)
destroy(this.m_sleepmode)
end on

type m_createmaintaincase from menu within m_features
event clicked ( )
end type

on clicked;/****************************************************************************************

			Event:	clicked
			Purpose:	To open the Create/Maintain Case window.

****************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_create_maintain_case, -1)
end on

on m_createmaintaincase.create
call super::create
this.text = "&Create/Maintain Case"
this.microhelp = "Opens the Create/Maintain Case window"
end on

on m_createmaintaincase.destroy
call super::destroy
end on

type m_workdesk from menu within m_features
event clicked ( )
end type

on clicked;/****************************************************************************************

			Event:	clicked
			Purpose:	To open the Reminders window.

****************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_reminders, -1)
end on

on m_workdesk.create
call super::create
this.text = "&Work Desk"
this.microhelp = "Opens the Work Desk window"
end on

on m_workdesk.destroy
call super::destroy
end on

type m_documentsfullinterface from menu within m_features
event clicked ( )
end type

event clicked;//***************************************************************************************
//
//  Event:    clicked
//  Purpose:  Opens the Document Full Interface Window
//
//***************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_docs_full_interface, -1)

end event

on m_documentsfullinterface.create
call super::create
this.text = "&Documents Full Interface"
this.microhelp = "Opens the Documents Full Interface Window"
end on

on m_documentsfullinterface.destroy
call super::destroy
end on

type m_recordsurveyresults from menu within m_features
event clicked ( )
end type

on clicked;/****************************************************************************************

			Event:	clicked
			Purpose:	To open the Record Survey Results window.

****************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_record_survey_results, -1)
end on

on m_recordsurveyresults.create
call super::create
this.text = "Record &Survey Results"
this.microhelp = "Opens the Record Survey Results window"
end on

on m_recordsurveyresults.destroy
call super::destroy
end on

type m_sleepmode from menu within m_features
event clicked ( )
end type

event clicked;/*****************************************************************************************
   Event:      clicked
   Purpose:    Place the application into sleep mode

   Revisions:
   Date     Developer    Description
   ======== ============ =================================================================
	05/25/01 M. Caruso    Created.
*****************************************************************************************/

w_mdi.fw_Sleep ()
end event

on m_sleepmode.create
call super::create
this.visible = false
this.text = "Sleep Mode"
this.enabled = false
this.microhelp = "Place the application in Sleep Mode."
this.toolbaritemvisible = false
this.toolbaritemname = "Custom015!"
this.toolbaritemtext = "Enter Sleep Mode"
end on

on m_sleepmode.destroy
call super::destroy
end on

type m_administration from menu within m_batch_correspondence
m_userlicenses m_userlicenses
m_options m_options
m_casehousekeeping m_casehousekeeping
m_tablemaintenance m_tablemaintenance
m_supervisorportal m_supervisorportal
m_lockedrecords m_lockedrecords
end type

on m_administration.create
call super::create
this.text = "&Administration"
this.m_userlicenses=create m_userlicenses
this.m_options=create m_options
this.m_casehousekeeping=create m_casehousekeeping
this.m_tablemaintenance=create m_tablemaintenance
this.m_supervisorportal=create m_supervisorportal
this.m_lockedrecords=create m_lockedrecords
this.Item[UpperBound(this.Item)+1]=this.m_userlicenses
this.Item[UpperBound(this.Item)+1]=this.m_options
this.Item[UpperBound(this.Item)+1]=this.m_casehousekeeping
this.Item[UpperBound(this.Item)+1]=this.m_tablemaintenance
this.Item[UpperBound(this.Item)+1]=this.m_supervisorportal
this.Item[UpperBound(this.Item)+1]=this.m_lockedrecords
end on

on m_administration.destroy
call super::destroy
destroy(this.m_userlicenses)
destroy(this.m_options)
destroy(this.m_casehousekeeping)
destroy(this.m_tablemaintenance)
destroy(this.m_supervisorportal)
destroy(this.m_lockedrecords)
end on

type m_userlicenses from menu within m_administration
m_updatelicenseinformation m_updatelicenseinformation
m_manageuserlogins m_manageuserlogins
end type

on m_userlicenses.create
call super::create
this.text = "&User Licenses"
this.m_updatelicenseinformation=create m_updatelicenseinformation
this.m_manageuserlogins=create m_manageuserlogins
this.Item[UpperBound(this.Item)+1]=this.m_updatelicenseinformation
this.Item[UpperBound(this.Item)+1]=this.m_manageuserlogins
end on

on m_userlicenses.destroy
call super::destroy
destroy(this.m_updatelicenseinformation)
destroy(this.m_manageuserlogins)
end on

type m_updatelicenseinformation from menu within m_userlicenses
event clicked ( )
end type

event clicked;/*****************************************************************************************
   Event:      clicked
   Purpose:    Open the user license maintenance window

   Revisions:
   Date     Developer    Description
   ======== ============ =================================================================
	8/7/00   M. Caruso    Created.
*****************************************************************************************/

SetPointer (HOURGLASS!)

FWCA.MGR.fu_OpenWindow (w_slu_main)
end event

on m_updatelicenseinformation.create
call super::create
this.text = "&Update License Information"
end on

on m_updatelicenseinformation.destroy
call super::destroy
end on

type m_manageuserlogins from menu within m_userlicenses
event clicked ( )
end type

event clicked;/*****************************************************************************************
   Event:      clicked
   Purpose:    Open the user login maintenance window

   Revisions:
   Date     Developer    Description
   ======== ============ =================================================================
	8/7/00   M. Caruso    Created.
*****************************************************************************************/

SetPointer (HOURGLASS!)

FWCA.MGR.fu_OpenWindow (w_slu_login_mgr)
end event

on m_manageuserlogins.create
call super::create
this.text = "&Manage User Logins"
end on

on m_manageuserlogins.destroy
call super::destroy
end on

type m_options from menu within m_administration
event clicked ( )
end type

event clicked;//*********************************************************************************************
//  Event:   clicked
//  Purpose: Acces the system options window.
//  
//  Date     Developer   Describe
//  -------- ----------- ----------------------------------------------------------------------
//  12/08/00 M. Caruso   Created.
//*********************************************************************************************

SetPointer (HOURGLASS!)
FWCA.MGR.fu_OpenWindow (w_system_options)
end event

on m_options.create
call super::create
this.text = "&Options"
this.toolbaritemvisible = false
end on

on m_options.destroy
call super::destroy
end on

type m_casehousekeeping from menu within m_administration
event clicked ( )
end type

on clicked;/****************************************************************************************

			Event:	clicked
			Purpose:	To open the Case Housekeeping window.

****************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_case_housekeeping, -1)
end on

on m_casehousekeeping.create
call super::create
this.text = "Case &Housekeeping"
this.microhelp = "Opens the Case Housekeeping window"
end on

on m_casehousekeeping.destroy
call super::destroy
end on

type m_tablemaintenance from menu within m_administration
event clicked ( )
end type

on clicked;/****************************************************************************************

			Event:	clicked
			Purpose:	To open the Table Maintenance window.

****************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_table_maintenance, -1)
end on

on m_tablemaintenance.create
call super::create
this.text = "&Table Maintenance"
this.microhelp = "Opens the Table Maintenance window"
end on

on m_tablemaintenance.destroy
call super::destroy
end on

type m_supervisorportal from menu within m_administration
end type

on m_supervisorportal.create
call super::create
this.text = "&Supervisor Portal"
end on

on m_supervisorportal.destroy
call super::destroy
end on

event clicked;/**************************************************************************************

			Event:	clicked
			Purpose:	To open the Supervisor Portal Window

***************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_supervisor_portal, -1)
end event

type m_lockedrecords from menu within m_administration
end type

event clicked;/**************************************************************************************

			Event:	clicked
			Purpose:	To open the Record Lock Administration window.

***************************************************************************************/

SetPointer(HOURGLASS!)
FWCA.MGR.fu_OpenWindow(w_lock_admin, -1)
end event

on m_lockedrecords.create
call super::create
this.text = "&Locked Records"
this.microhelp = "Locked Records"
this.toolbaritemtext = "Locked Records"
end on

on m_lockedrecords.destroy
call super::destroy
end on

type m_window from menu within m_batch_correspondence
m_tile m_tile
m_layer m_layer
m_cascade m_cascade
m_windowsep1 m_windowsep1
m_arrangeicons m_arrangeicons
m_windowsep2 m_windowsep2
m_closeall m_closeall
end type

on m_window.create
call super::create
this.text = "&Window"
this.m_tile=create m_tile
this.m_layer=create m_layer
this.m_cascade=create m_cascade
this.m_windowsep1=create m_windowsep1
this.m_arrangeicons=create m_arrangeicons
this.m_windowsep2=create m_windowsep2
this.m_closeall=create m_closeall
this.Item[UpperBound(this.Item)+1]=this.m_tile
this.Item[UpperBound(this.Item)+1]=this.m_layer
this.Item[UpperBound(this.Item)+1]=this.m_cascade
this.Item[UpperBound(this.Item)+1]=this.m_windowsep1
this.Item[UpperBound(this.Item)+1]=this.m_arrangeicons
this.Item[UpperBound(this.Item)+1]=this.m_windowsep2
this.Item[UpperBound(this.Item)+1]=this.m_closeall
end on

on m_window.destroy
call super::destroy
destroy(this.m_tile)
destroy(this.m_layer)
destroy(this.m_cascade)
destroy(this.m_windowsep1)
destroy(this.m_arrangeicons)
destroy(this.m_windowsep2)
destroy(this.m_closeall)
end on

type m_tile from menu within m_window
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_Tile
//  Event         : Clicked
//  Description   : Arrange the open windows so that no windows in
//                  the MDI frame overlap but all windows are
//                  visible.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF FWCA.MGR.i_MDIValid THEN
   ArrangeSheets(FWCA.MGR.i_MDIFrame, Tile!)
END IF
end on

on m_tile.create
call super::create
this.text = "&Tile"
this.microhelp = "Arrange the window tile"
end on

on m_tile.destroy
call super::destroy
end on

type m_layer from menu within m_window
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_Tile
//  Event         : Clicked
//  Description   : Arrange the open windows so that no windows in
//                  the MDI frame overlap but all windows are
//                  visible.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF FWCA.MGR.i_MDIValid THEN
   ArrangeSheets(FWCA.MGR.i_MDIFrame, Layer!)
END IF
end on

on m_layer.create
call super::create
this.text = "La&yer"
this.microhelp = "Arrange the window as layerd"
end on

on m_layer.destroy
call super::destroy
end on

type m_cascade from menu within m_window
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_Tile
//  Event         : Clicked
//  Description   : Arrange the open windows so that no windows in
//                  the MDI frame overlap but all windows are
//                  visible.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF FWCA.MGR.i_MDIValid THEN
   ArrangeSheets(FWCA.MGR.i_MDIFrame, Cascade!)
END IF
end on

on m_cascade.create
call super::create
this.text = "&Cascade"
this.microhelp = "Arrange the window as cascade"
end on

on m_cascade.destroy
call super::destroy
end on

type m_windowsep1 from menu within m_window
end type

on m_windowsep1.create
call super::create
this.text = "-"
end on

on m_windowsep1.destroy
call super::destroy
end on

type m_arrangeicons from menu within m_window
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_Tile
//  Event         : Clicked
//  Description   : Arrange the open windows so that no windows in
//                  the MDI frame overlap but all windows are
//                  visible.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF FWCA.MGR.i_MDIValid THEN
   ArrangeSheets(FWCA.MGR.i_MDIFrame, Icons!)
END IF
end on

on m_arrangeicons.create
call super::create
this.text = "&Arrange Icons"
this.microhelp = "Arrange the window icons"
end on

on m_arrangeicons.destroy
call super::destroy
end on

type m_windowsep2 from menu within m_window
end type

on m_windowsep2.create
call super::create
this.text = "-"
end on

on m_windowsep2.destroy
call super::destroy
end on

type m_closeall from menu within m_window
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_CloseAll
//  Event         : Clicked
//  Description   : Close all the windows in the MDI frame that
//                  have been open using the Window_Open function.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

IF FWCA.MGR.i_MDIValid THEN
   TriggerEvent(FWCA.MGR.i_MDIFrame, "pc_CloseAll")
END IF
end on

on m_closeall.create
call super::create
this.text = "C&lose All"
this.microhelp = "Closes all open windows"
end on

on m_closeall.destroy
call super::destroy
end on

type m_help from menu within m_batch_correspondence
m_index m_index
m_usinghelp m_usinghelp
m_helpsep1 m_helpsep1
m_about m_about
end type

on m_help.create
call super::create
this.text = "&Help"
this.m_index=create m_index
this.m_usinghelp=create m_usinghelp
this.m_helpsep1=create m_helpsep1
this.m_about=create m_about
this.Item[UpperBound(this.Item)+1]=this.m_index
this.Item[UpperBound(this.Item)+1]=this.m_usinghelp
this.Item[UpperBound(this.Item)+1]=this.m_helpsep1
this.Item[UpperBound(this.Item)+1]=this.m_about
end on

on m_help.destroy
call super::destroy
destroy(this.m_index)
destroy(this.m_usinghelp)
destroy(this.m_helpsep1)
destroy(this.m_about)
end on

type m_index from menu within m_help
end type

on m_index.create
call super::create
this.text = "&Index"
this.microhelp = "Display help"
this.toolbaritemvisible = false
this.toolbaritemname = "Help!"
end on

on m_index.destroy
call super::destroy
end on

event clicked;//******************************************************************
//  PC Module     : m_Help.m_Index
//  Event         : Clicked
//  Description   : Display the help file for the application.
//                  Replace <application_file> with the name of
//                  the application help file.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//  6/21/99  M. Caruso  Added code to call the CF help file.
//  4/26/00  M. Caruso  Changed code to call the new help file.
//  1/16/01  M. Caruso  Updated the help file name.
//******************************************************************
//  Copyright ServerLogic 1992-1994.  All Rights Reserved.
//******************************************************************

SetPointer(HourGlass!)
//ShowHelp("jtdoc2.hlp", Index!)
Run ("hh.EXE CFuser.chm")
end event

type m_usinghelp from menu within m_help
end type

on clicked;//******************************************************************
//  PC Module     : m_Main.m_UsingHelp
//  Event         : Clicked
//  Description   : Display the "Windows Help" help file.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

SetPointer(HourGlass!)
ShowHelp("winhelp.hlp", Index!)
end on

on m_usinghelp.create
call super::create
this.text = "&Using Help"
this.microhelp = "Display ~"Using Windows Help~""
end on

on m_usinghelp.destroy
call super::destroy
end on

type m_helpsep1 from menu within m_help
end type

on m_helpsep1.create
call super::create
this.text = "-"
end on

on m_helpsep1.destroy
call super::destroy
end on

type m_about from menu within m_help
end type

event clicked;//******************************************************************
//  PC Module     : m_Main.m_About
//  Event         : Clicked
//  Description   : Open a window that describes something about
//                  the application.  By default, this window will
//                  display the application name and revision that
//                  are stored in the PCCA structure.  This window
//                  can be redefined if a custom window is desired.
//
//  Change History:
//
//  Date     Person     Description of Change
//  -------- ---------- --------------------------------------------
//
//******************************************************************
//  Copyright ServerLogic 1992-1993.  All Rights Reserved.
//******************************************************************

SetPointer(HourGlass!)
Open(w_cf_about)
end event

on m_about.create
call super::create
this.text = "&About..."
this.microhelp = "Display information about the application"
end on

on m_about.destroy
call super::destroy
end on

